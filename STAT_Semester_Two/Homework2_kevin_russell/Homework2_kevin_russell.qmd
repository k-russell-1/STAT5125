---
title: "Homework 2 Kevin Russell"
format: 
  html:
    embed-resources: true
---
# Problem 1

For our first problem, we will use data obtained from past Eurovision song contests. The data can be found as contestants.Rda and votes.Rda on HuskyCT.

## Part A

Part A of the problem will concern the data available in contestants.Rda.

```{r}
library(dplyr)
library(tidyverse)
library(ggplot2)
```

### Question (i). 8 points.

Load the "contestants" data frame into R.

```{r}
load("C:/Users/kruss/Downloads/contestants.Rda")

contestants |>
  glimpse()
```

Using this data frame as a starting point, apply dplyr verbs to create another data frame which meets the following criteria:

-   include exactly two columns: one named performer, and another named nperformances. The cells of performer should give the names of performers. The cells in nperformances should tell us the number of times a performer appeared in the dataset.

-   Do not include any performers with fewer than three Eurovision performances.

-   Sort the rows such that they are in descending order based on the number of performances. For example, anyone with four performances should appear above anyone with three performances.

```{r}
three_perfs <- contestants |>
  group_by(performer) |>
  summarize(nperformances = n()) |>
    filter(nperformances >= 3) |>
    arrange(desc(nperformances))

three_perfs
```

### Question (ii). 8 points.

Using dplyr verbs, create a one-row data frame that reports the number of missing values in each column of the original contestants data frame.

```{r}
contestants |>
  select(everything()) |>
  summarise_all(funs(sum(is.na(.))))
```

### Question (iii). 8 points.

Occasionally, a country in contestants has had more than one performer in a given year. How many times does this occur in the contestants data frame?

```{r}
contestants |>
  group_by(to_country, year) |>
  summarize(nperformances = n()) |>
  filter(nperformances > 1)
```

REPORT NUMBER OF INSTANCES IN WORDS HERE.
Twenty

### Question (iv). 8 points.

To eliminate the cases discovered in (iii), create a new data frame named contestants_fixed.

contestants_fixed should be identical to contestants, except it should contain at most one performer for each country-year combination. If more there is more than one performer for a country-year combination in contestants, contestants_fixed should keep only the one with the highest running_final score. 

Hint: if using a slice_max verb, it may be helpful to include a with_ties = FALSE argument.

```{r}
contestants |>
  group_by(to_country, year) |>
  slice_max(running_final, with_ties = FALSE, n = 1)
```

### Question (v). 8 points.

Using the data frame you created in (iv), create a new data frame "contestants_fixed_wider" where:

-   each row represents a year,
-   each column is a country, and
-   the cell values are the number of points each country got in the final (i.e. the variable named points_final). If a country didn't participate in the final, the cell value should be NA.

```{r}
contestants_fixed_wider <- 
  contestants |>
    pivot_wider(names_from = to_country,
                values_from = points_final) |>
  select(year, Switzerland:Czechia) |>
   mutate_all(~ ifelse(is.na(.), 0, .)) |>
  group_by(year) |>
  summarise_all(sum) |>
  mutate_all(~ na_if(., 0))
    

contestants_fixed_wider
```

## Part B

Part B will concern the data available in votes.Rda

### Question (i). 6 points.

Start by loading the votes data into R. 

```{r}
load("C:/Users/kruss/Downloads/votes.Rda")
```

Then, create a new data frame called votes_complete. votes_complete should contain only those rows which have non-NA observations for both the tele_points and jury_points variables.

```{r}
votes_complete <-
  votes |>
  filter(is.na(tele_points) == FALSE) |>
  filter(is.na(jury_points) == FALSE)
```

How many years are represented in this new votes_complete data frame?

```{r}
years <- votes |> 
  distinct(year)

nrow(years)
```

REPORT NUMBER OF YEARS AS A SENTENCE HERE.
Sixty-six distinct years are represented in the votes_complete df.

### Question (ii). 8 points.

Apply dplyr verbs to transform votes_complete into a new data frame named votes_complete_agg with 5 columns: year, from_country, to_country, tele_points, and jury_points.

tele_points and jury_points should be the sum of these values across the three rounds: final, semi-final-1, and semi-final-2.

```{r}
# INSERT CODE HERE
votes_complete_agg <-
votes_complete |>
  group_by(year, from_country, to_country) |>
  summarise(tele_points = sum(tele_points),
            jury_points = sum(jury_points))

votes_complete_agg
```

Over the years, which four countries sent the most jury points to Poland?

```{r}
votes_complete_agg |>
  group_by(from_country, to_country) |>
  summarise(tele_points = sum(tele_points),
  jury_points = sum(jury_points)) |>
  filter(to_country == "Poland") |>
  arrange(desc(jury_points))
```

REPORT ANSWER IN WORDS HERE.
San Marino, Australia, Azerbaijan, and Israel.

### Question (iii). 10 points.

Consider the countries Sweden, Denmark, and Norway.

Transform votes_complete_agg into a data frame that can be used to create the following faceted plot.

```{r}
votes_ready <- 
votes_complete_agg |>
  filter(to_country %in% c("Sweden", "Denmark", "Norway")) |>
  filter(from_country %in% c("Sweden", "Denmark", "Norway")) |>
  filter(year >= 2018) |>
  pivot_longer(cols = c(tele_points, jury_points))

votes_ready
```

Note that the plot shows how the jury_points and tele_points exchanged between these countries varied from year to year. Once you have the correct data frame, recreate the plot.

```{r}
votes_ready |>
    ggplot(aes(x = year, 
             y = value,
             shape = name,
             linetype = name)) +
  geom_line() +
  geom_point() +
  facet_grid(from_country ~ to_country) +
  theme(legend.position="top") + 
  labs(y = "point_total", shape = "point_type", linetype = "point_type")
```

# Problem 2

## Part A. 30 points.

Attached to the homework on HuskyCT, there are four Rda files: tmax.Rda, tmin.Rda, prcp.Rda, and tmax_tmin_prcp.Rda. These files provide historical weather data for four cities: Philadelphia, PA; Pittsburgh, PA; Erie, PA; Cleveland, OH. tmax is the max daily temperature, tmin is the min daily temperature, and prcp is the daily precipitation.

tmax.Rda, tmin.Rda, prcp.Rda are untidy representations of pieces of the weather data---one for tmax, one for tmin, and one for prcp. tmax_tmin_prcp.Rda is a tidy version of the three datasets brought together.

Your task is to use tmax.Rda, tmin.Rda, and prcp.Rda to exactly replicate the contents of tmax_tmin_prcp.Rda. This should be accomplished through a series of tidyverse verbs.

Please provide all the code to go from tmax.Rda, tmin.Rda, and prcp.Rda to a single dataframe matching tmax_tmin_prcp. 


```{r}
# INSERT DATA LOADING CODE HERE
load("C:/Users/kruss/Downloads/tmax.Rda")
load("C:/Users/kruss/Downloads/tmin.Rda")
load("C:/Users/kruss/Downloads/prcp.Rda")
load("C:/Users/kruss/Downloads/tmax_tmin_prcp.Rda")
```


```{r}
# INSERT tmax manipulation CODE HERE
tmax_tidy <- tmax |>
  pivot_longer(
    cols = "pit,pa,01,01":"cle,oh,29,02",
    names_to = c("City", "State", "Day", "Month"), 
    names_pattern = "(.*),(.*),(.*),(.*)"
  )
```

```{r}
tmax_tidy <- tmax_tidy |>
  mutate(State = toupper(State),
         City = ifelse(City == "pit", "Pittsburgh", (ifelse(City == "cle", "Cleveland", ifelse(City == "phi", "Philadelphia", "Erie"))))) |>
  mutate(Day = parse_number(Day)) |>
  mutate(tmax = value)
```

```{r}
tmax_tidy <- subset(tmax_tidy, select = -c(value))
```


```{r}
tmin_tidy <- tmin |>
  pivot_longer(
    cols = "pit_pa_01":"cle_oh_31",
    names_to = c("City", "State", "Day"), 
    names_pattern = "(.*)_(.*)_(.*)"
  )
```


```{r}
tmin_tidy <- tmin_tidy |>
  mutate(State = toupper(State),
         City = ifelse(City == "pit", "Pittsburgh", (ifelse(City == "cle", "Cleveland", ifelse(City == "phi", "Philadelphia", "Erie"))))) |>
  mutate(Day = parse_number(Day)) |>
  mutate(tmin = value,
         Month = month)
```

```{r}
tmin_tidy <- subset(tmin_tidy, select = -c(value, month))
```


```{r}
prcp_tidy <- prcp |>
  pivot_longer(
    cols = "date01__01":"date29__02",
    names_to = c("Day", "Month"), 
    names_pattern = "date(.*)__(.*)"
  )
```

```{r}
prcp_tidy <- prcp_tidy |>
  mutate(Day = parse_number(Day),
         prcp = value,
         State = state,
         City = city)
```

```{r}
prcp_tidy <- subset(prcp_tidy, select = -c(value, city, state))
```


```{r}
# INSERT joining and cleaning CODE HERE
temp <- tmax_tidy |>
  left_join(tmin_tidy)

final <- temp |>
  left_join(prcp_tidy)
```


```{r}
# INSERT CODE that verifies your success HERE
# HINT: consider using names() to verify columns coincide
# HINT: consider using anti_join() to verify all rows are included.

final |>
  anti_join(tmax_tmin_prcp) |>
  count()
```
```{r}
tmax_tmin_prcp |>
  anti_join(final) |>
  count()
```


## Part B

### Question (i). 6 points.

Consider the data in tmax_tmin_prcp.Rda from 1971 to 2017. Is there any pattern to which days are missing temperatures? What do you think is causing this?

```{r}
tmax_tmin_prcp |>
  filter(is.na(tmax),
         year >= 1971,
         year <= 2017)
```

EXPLANATION GOES HERE.
It certainly seems as though the leap days (February 29th) are the ones that are not being tracked. This is because those days do not exist most years. For instance, all cities are NA for February 29th, 2017. There was no 2/29/2017.


### BONUS Question (ii). 10 Points.

Provide code to create the following graphic showing the average maximum and minimum temperature per year across the four cities from 1971 to 2017.

```{r}
avg_temp <- tmax_tmin_prcp |>
  filter(is.na(tmin) == FALSE,
         is.na(tmax) == FALSE) |>
  group_by(year, City, State) |>
  summarise(tmin = mean(tmin),
            tmax = mean(tmax)) |>
  pivot_longer(cols = c(tmin, tmax))
  
avg_temp |>
    ggplot(aes(x = year, y = value, color = City, linetype = name)) +
  geom_line() + 
  labs(y = "Temperature", linetype = "Average_Daily")

```