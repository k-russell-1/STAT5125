---
title: "Homework 6"
author: Kevin Russell
format: 
  html:
    embed-resources: true
---


As part of the homework, I have provided a zipped file called shoes that contains tiff images of 159 shoe prints. I have also provided a csv called Image-info.csv containing info on each of these shoes. 

For this homework, we will set up functions and an automatic pipeline to:
- read all of these shoes into R, 
- transform them into tidy data frames,
- trim the images to remove the ruler images along the boundary
- convert the image into a cloud of points
- use PCA to align this cloud of points

One we've written this pipeline, we will then do some analysis of the aligned point clouds.

# Question 1 [52 Points]

```{r}
#| message: FALSE
#| warning: FALSE
library(tidyverse)
library(tiff)
library(broom)
theme_set(theme_bw())
```

## Part A [10 Points]

Read all of the shoe images into a tibble named images_df. images_df should have 159 rows and two columns.

One column should shoe be the file name of each shoe in the dataset. The other column should be a list column containing the output of readTIFF() for each file name.

```{r}
files <- unzip("shoes.zip", list=TRUE)
file_names <- files$Name
```

```{r}
indices_to_keep <- grep("\\.tiff$", file_names)
file_names <- file_names[indices_to_keep]
indices_to_keep <- grep("^shoes2", file_names)
file_names <- file_names[indices_to_keep]
```

```{r}
file_list = list()
for (i in 1:159) {
  file_list = c(file_list, paste0("shoes/", file_names[i]))
}
```

```{r}
tif_list <- lapply(file_list, readTIFF)
```

```{r}
df <- tibble(file_name = file_names, tiff_data = tif_list)
```

## Part B [8 Points]

Write a function called tidy_shoe_image that takes in the matrix output of readTIFF and returns a tibble with one row each for pixel in the image. The tibble should have three columns:

x: the horizontal coordinate of the pixel in the image,
y: the vertical coordinate of the pixel in the image,
value: the value of the pixel,

All three columns should be numeric. 

```{r}
library(dplyr)

tidy_tibble <- function(matrix){
  df1 <- as.data.frame(matrix)
  df1 <- df1 |>
    mutate(row = row_number()) |>
    pivot_longer(cols = -row, names_to = "x", values_to = "value") |>
    mutate(y = 913 - row) |>
    dplyr::select(-row) |>
    mutate(x = sub("X", "", x, fixed = TRUE)) |>
    mutate(x = as.numeric(x))
  return(as_tibble(df1))
}
  
test_df <- tidy_tibble(tif_list[10])
```

Use this function to create include a new list column in images_df containing the tidy tibble for each image.

```{r}
tidytibble <- list()
for (i in 1:159){
  tibble1 <- tidy_tibble(tif_list[i])
  tidytibble <- c(tidytibble, tibble1)
}
chunks <- split(tidytibble, rep(1:159, each = 3))

list_of_tibbles <- lapply(chunks, function(chunk) {
  as_tibble(do.call(cbind, chunk))
})
```

```{r}
images_df <- df

images_df <- images_df |>
  mutate(tidytibble = list_of_tibbles)
  
```


## Part C [4 Points]

Consider the following function.

```{r}
visualize_shoe_raster <- function(img_dat){
  img_dat |>
    ggplot(aes(x = x,
               y = y,
               fill = value)) +
    geom_raster() +
    coord_fixed() +
    scale_fill_gradient(low = "black",
                        high = "white") +
    theme(legend.position = "none")
}
```

Show that if you use this function on the tidy tibble corresponding to the file "002054L_20171027_2_1_1_csafe_tpashek.tiff", you get the following result.

```{r}
row <- images_df |>
  filter(str_detect(file_name, "002054L_20171027_2_1_1_csafe_tpashek.tiff"))
```

```{r}

df <- as.data.frame(row$tidytibble[1])

df <- df |>
  mutate(x = X27.x,
         y = X27.y,
         value = X27.value) |>
  select(x, y, value)

visualize_shoe_raster(df)

```

## Part D [6 Points]

Though the image above looks pretty good, note that the numbers around the side are not really part of the shoe image. 

Write a function called remove_shoe_boundary that takes in a tidy tibble of the form we created above, then filters it to remove all pixels that are within 50 of the boundary of the image.  

```{r}
remove_shoe_boundary <- function(img_dat){
  max_y <- max(img_dat$y) - 50
  max_x <- max(img_dat$x) - 50
  img_dat <- img_dat |>
    filter(x > 50,
           x < max_x,
           y > 50,
           y < max_y)
  return(img_dat)
}

```

Use this function to make a new list column called img_noboundaries in images_df that contains the images without the boundary included.

```{r}
images_df <- images_df |>
  mutate(img_noboundaries = lapply(tidytibble, remove_shoe_boundary))
```

For instance, if you use visualize_shoe_raster() on the img_boundaries version of "002054L_20171027_2_1_1_csafe_tpashek.tiff", you should get the following result.

```{r}
row <- images_df |>
  filter(str_detect(file_name, "002054L_20171027_2_1_1_csafe_tpashek.tiff"))

df <- as.data.frame(row$img_noboundaries[1])

df <- df |>
  mutate(x = X27.x,
         y = X27.y,
         value = X27.value) |>
  select(x, y, value)

visualize_shoe_raster(df)
```

## Part E [4 Points]

Next, we want to convert each shoe print image into a point cloud. Consider the function:

```{r}
get_shoe_cloud <- function(shoe){
  shoe |>
    filter(value < 0.5) |>
    dplyr::select(x, y) 
}
```

Use this function to create a new list column called shoe_cloud in images_df. This column should contain the point cloud obtained using get_shoe_cloud for each shoe in the dataset.

```{r}
images_df <- images_df |>
  mutate(shoe_cloud = lapply(img_noboundaries, get_shoe_cloud))
```

## Part F [2 Points]

Consider the following function. 

```{r}
visualize_shoe_cloud <- function(img_dat){
  img_dat |>
    ggplot(aes(x = x, y = y)) +
    geom_tile(width = 1, height = 1) +
    coord_fixed()
}
```

Use this function to visualize the point cloud for "002054L_20171027_2_1_1_csafe_tpashek.tiff". It should look like the following.

```{r}
row <- images_df |>
  filter(str_detect(file_name, "002054L_20171027_2_1_1_csafe_tpashek.tiff"))

df <- as.data.frame(row$shoe_cloud[1])

df <- df |>
  mutate(x = X27.x,
         y = X27.y) |>
  select(x, y)

visualize_shoe_cloud(df)
```

## Part G [10 Points]

Write a function called align_shoe_cloud that uses PCA to align the shoe cloud such that the direction of most variation runs vertically. The aligned shoe should still be pointed toe-up, and not flipped.

```{r}
pull_x <- function(mat){
  val <- mat |>
    filter(column == "x",
           PC == 2)
  return(val$value[1])
}
  
pull_y <- function(mat){
  val <- mat |>
    filter(column == "y",
           PC == 1)
  return(val$value[1])
}
  
aligned_image <- function(cloud){
  pca <- cloud |>
    dplyr::select(x,
                  y) |>
    prcomp()
  rm <- rotation_matrix(cloud)
    aligned <- cloud  |>
      mutate(x = pca$x[,2],
           y = pca$x[,1])
  if(pull_x(rm) < 0){
    aligned <- aligned |>
      mutate(x = -x)
  }  
  if(pull_y(rm) < 0){
    aligned <- aligned |>
      mutate(y = -y)
  }
    
  return(aligned)
}


```


```{r}
rotation_matrix <- function(cloud){
  pca <- cloud |>
    dplyr::select(x,
                  y) |>
    prcomp() |>
    tidy(matrix = "rotation")
  return(pca)
}
```

Use this function to create a new column in images_df called shoe_cloud_aligned that contains all of the aligned shoe images. 

```{r}
images_df <- images_df |>
  mutate(shoe_cloud_aligned = lapply(shoe_cloud, aligned_image))
```


Note: Ensuring the shoes do not get flipped is a difficult task. Use visualize_shoe_cloud() before and after the alignment to double-check that your function is properly correcting the flip of each image. As a hint, inspect the PCA rotation matrix for shoes that do get flipped, versus those that don't. You may notice a pattern that you can exploit to ensure the shoes are pointed upward.

## Part H [8 Points]

Now that you have the aligned shoe cloud, discard all columns from images_df except file_name and shoe_cloud_aligned.

```{r}
images_df <- images_df |>
  select(file_name, shoe_cloud_aligned)
```

Use this data frame and visualize_shoe_cloud() to create a faceted plot of the following 4 aligned shoes:

- "002054L_20171027_2_1_1_csafe_tpashek.tiff"
- "002054L_20171027_2_2_1_csafe_tpashek.tiff"
- "002054L_20171027_2_1_2_csafe_tpashek.tiff"
- "002054L_20171027_2_2_2_csafe_tpashek.tiff"

It should resemble the following [hint: you can simply add facet_wrap() to the output of visualize_shoe_cloud()]

```{r}
plot <- images_df |>
  filter(str_detect(file_name, "002054L_20171027_2_1_1_csafe_tpashek.tiff") | str_detect(file_name,   "002054L_20171027_2_2_1_csafe_tpashek.tiff") | str_detect(file_name, "002054L_20171027_2_1_2_csafe_tpashek.tiff") | str_detect(file_name, "002054L_20171027_2_2_2_csafe_tpashek.tiff"))
```




```{r}
df <- as.data.frame(images_df$shoe_cloud_aligned[10])

df <- df |>
  mutate(x = X10.x,
         y = X10.y) |>
  select(x, y)

visualize_shoe_cloud(df)
```


```{r}

plot |>
  unnest(shoe_cloud_aligned) |>
  visualize_shoe_cloud() +
  facet_wrap(~file_name, ncol = 4)
```

# Question 2 [34 Points Total]

Now, let's do some analysis of the data.

## Part A [4 Points]

Note that, on HuskyCT, I also shared the data file Image-info.csv. Read this file into R and make it into a tibble called image_info. Apply the janitor function clean_names() to clean up the names of the columns.

```{r}
library(janitor)
image_info <- read.csv("Image-info.csv")
image_info <- clean_names(image_info)
```

Join image_info and images_df into a single data frame with one row per shoe. Exclude any images for which there is no matching entry in Image_info. Name this new data frame shoes_df

```{r}
images_df <- images_df |>
  mutate(file_name = sub("shoes2/", "", file_name))
```

```{r}
shoes_df <- images_df |>
  inner_join(image_info, by = "file_name")
```

## Part B [10 Points]

Create new columns for shoes_df called image_length and image_width that contains the vertical length of each shoe, and the horizontal width as measured by the distance between the most extreme pixels along that direction.

```{r}
horizontal <- function(cloud){
  min1 <- min(cloud$x)
  max1 <- max(cloud$x)
  return(max1 - min1)
}

vertical <- function(cloud){
  min1 <- min(cloud$y)
  max1 <- max(cloud$y)
  return(max1 - min1)
}

shoes_df <- shoes_df |>
  mutate(image_width = lapply(shoe_cloud_aligned, horizontal)) |>
  mutate(image_length = lapply(shoe_cloud_aligned, vertical))
```

Create a scatter plot of shoe_width versus shoe_length colored by the variable shoe_size. Does the result match your expectations?

```{r}
shoes_df |>
  ggplot(aes(x = as.numeric(image_width),
             y = as.numeric(image_length),
             color = shoe_size)) +
  geom_point() +
  labs(x = "Width", y = "Length", color = "Shoe Size")
```
The results are more or less what I expected. Men's size 10 shoes are pretty uniformly longer than women's size 7 shoes, save for a few extreme outliers. However, the width is more comparable between the two sizes.

## Part C [10 Points]

Some of the shoes in our dataset are left shoes, and some are right shoes. Thankfully, the file_name tells us which is with by including an L or a R. Create a new column for shoes_df that indicates the "chirality" (left or rightness) of the shoe.

```{r}
chirality_list <- list()

for(i in 1:151){
  if(grepl("L", shoes_df$file_name[i])){
    chirality_list <- c(chirality_list, "L")
  }
  else{
    chirality_list <- c(chirality_list, "R")
  }
}

shoes_df <- shoes_df |>
  mutate(chirality = chirality_list)
```

Recreate the following two faceted plots to show the typical shoe for each combination of size and chirality.

10 Men's

```{r}
mens <- shoes_df |>
  filter(shoe_size == "10 M")
```


```{r}
x_list = list()
y_list = list()
num = list()
for(i in 1:64){
  x_list = c(x_list, mens$shoe_cloud_aligned[[i]]$x)
  y_list = c(y_list, mens$shoe_cloud_aligned[[i]]$y)
  num = c(num, rep(i, length(mens$shoe_cloud_aligned[[i]]$y)))
  print(i)
}

```

```{r}
indices <- unlist(num)

chirality <- mens$chirality[indices]

chirality <- unlist(chirality, recursive = FALSE)
```

```{r}
df <- data.frame(x = unlist(x_list),
                 y = unlist(y_list),
                 chiral = unlist(chirality))
```


```{r}
df |>
  ggplot(aes(x = x,
             y = y)) +
  geom_bin_2d() +
  scale_fill_gradient(low = "white",
                      high = "red") +
  facet_wrap(~chiral)
```


7 Women's 

```{r}
womens <- shoes_df |>
  filter(shoe_size == "7 W")
```


```{r}
x_list = list()
y_list = list()
num = list()
for(i in 1:87){
  x_list = c(x_list, womens$shoe_cloud_aligned[[i]]$x)
  y_list = c(y_list, womens$shoe_cloud_aligned[[i]]$y)
  num = c(num, rep(i, length(womens$shoe_cloud_aligned[[i]]$y)))
  print(i)
}

```

```{r}
indices <- unlist(num)

chirality <- womens$chirality[indices]

chirality <- unlist(chirality, recursive = FALSE)
```

```{r}
df <- data.frame(x = unlist(x_list),
                 y = unlist(y_list),
                 chiral = unlist(chirality))
```


```{r}
df |>
  ggplot(aes(x = x,
             y = y)) +
  geom_bin_2d() +
  scale_fill_gradient(low = "white",
                      high = "red") +
  facet_wrap(~chiral)
```



## Part D [10 Points]

Note that our image set consists of images of five pairs of shoes being worn by their owners over a duration of time consisting of four visits with the experimenters for the shoes to be imaged.

The variable shoe_number provides a unique identifier for each pair of shoes, the variable visit_number tells us which visit the shoe is being imaged on. At each visit, each shoe was imaged twice, with replicate_number indicating whether it was the first or second imaging.

Suppose we want to investigate whether the amount of contact a shoe had with the ground varied as it was worn. To do this, we want to plot how the number of points in the point cloud of each shoe changes over time, averaged across the two replicates of each shoe.

Do the required manipulations to reproduce the following plot.

```{r}
length1 = list()
for(i in 1:151) {
  length1 <- c(length1, length(shoes_df$shoe_cloud_aligned[[i]]$y))
}
```

```{r}
shoes_grouped <- shoes_df |>
  mutate(points = as.numeric(length1)) |>
  group_by(visit_number, shoe_number, chirality) |>
  summarize(points = mean(points)) |>
  mutate(chirality = unlist(chirality)) |>
  mutate(shoe_number = as.factor(shoe_number))

```
```{r}
shoes_grouped |>
  ggplot(aes(x = visit_number,
             y = points)) +
  geom_line(aes(color = shoe_number)) + 
  geom_point(aes(color = shoe_number)) +
  facet_wrap(~chirality) +
  ylim(0, 40500) +
  labs(x = "Visit Number", y = "Number of Points in Image", color = "Shoe Number")+
  theme(legend.position = "top")
```

Do you notice any sort of general trend?
For a majority of the shoe images, point count increases from visit 0 to visit 1 and then from visit 1 to visit 2. Interestingly, from there, visit 3 represents a general decrease. 


# Problem 3 [16 Points Total]

Consider the got_chars dataset contained with the repurrrsive library.

```{r}
library(repurrrsive)
game_of_thrones <- tibble(got_chars)
```

## Part A [6 Points]

Use the game_of_thrones tibble to create a new tibble called got_allegiances with two columns: character_name and allegiance. It should have one row for each allegiance that each character has.

```{r}
close <- game_of_thrones |>
  rowwise() |>
  mutate(chars_df = list(enframe(got_chars,
                                 name = "category",
                                 value = "value"))) |>
  select(chars_df) |>
  unnest(chars_df) |>
  mutate(value = lapply(value, as.character)) |>
  unnest(value) |>
  filter(category == "name" | category == "allegiances")
```





Print out the entire data frame.

```{r}
close
```


## Part B [10 Points]

Create a data frame called character_seasons with three columns: 
- character_name, 
- number_of_seasons, and 
- first_appeared. 

The column character_name should show the name of each character, the column number_of_seasons should tell how many seasons the character appeared in, and the column first_appeared should be a factor showing the first season of the show that the character appeared in. Information on season appearances can be found under $tvSeries. 

If the character did not appear in any seasons, first_appeared should be set to NA, and number_of_seasons should be set to 0.

```{r}
int_tibble <- game_of_thrones |>
  rowwise() |>
  mutate(chars_df = list(enframe(got_chars,
                                 name = "category",
                                 value = "value"))) |>
  select(chars_df) |>
  unnest(chars_df) |>
  mutate(value = lapply(value, as.character)) |>
  unnest(value) |>
  filter(category == "name" | category == "tvSeries") |>
  mutate(id = cumsum(category == "name"))
  
```

```{r}
name <- int_tibble |>
  filter(category == "name") |>
  dplyr::select(value, id)

seasons <- int_tibble |>
  filter(category == "tvSeries") |>
  select(value, id) |>
  mutate(value = parse_number(value)) |>
  group_by(id) |>
  summarize(first_appeared = min(value),
            number_of_seasons = n()) |>
  mutate(number_of_seasons = ifelse(is.na(first_appeared), 0, number_of_seasons)) |>
  inner_join(name, by="id") |>
  mutate(name = value) |>
  dplyr::select(c(-id, -value))
  

```

Print all rows of the data frame.

```{r}
seasons
```

